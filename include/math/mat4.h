#pragma once

#include "vec4.h"

namespace Raytracer::Math {
struct mat4
{
  constexpr mat4() noexcept
    : m{ {1.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f, 0.0f},
         {0.0f, 0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 1.0f} }
  {}
  constexpr mat4(float e00,
                 float e10,
                 float e20,
                 float e30,
                 float e01,
                 float e11,
                 float e21,
                 float e31,
                 float e02,
                 float e12,
                 float e22,
                 float e32,
                 float e03,
                 float e13,
                 float e23,
                 float e33) noexcept
    : m{ {e00, e10, e20, e30}, {e01, e11, e21, e31},
         {e02, e12, e22, e32}, {e03, e13, e23, e33} }
  {}

  float m[4][4];
};

inline vec4
dot(const mat4& m, const vec4& v)
{
  return vec4(
    m.m[0][0] * v.e[0] + m.m[1][0] * v.e[1] + m.m[2][0] * v.e[2] + m.m[3][0] * v.e[3],
    m.m[0][1] * v.e[0] + m.m[1][1] * v.e[1] + m.m[2][1] * v.e[2] + m.m[3][1] * v.e[3],
    m.m[0][2] * v.e[0] + m.m[1][2] * v.e[1] + m.m[2][2] * v.e[2] + m.m[3][2] * v.e[3],
    m.m[0][3] * v.e[0] + m.m[1][3] * v.e[1] + m.m[2][3] * v.e[2] + m.m[3][3] * v.e[3]);
}

inline mat4
dot(const mat4& l, const mat4& r)
{
  return {
    // 0,0
    l.m[0][0] * r.m[0][0] + l.m[1][0] * r.m[0][1] + l.m[2][0] * r.m[0][2] + l.m[3][0] * r.m[0][3],
    // 1,0
    l.m[0][0] * r.m[1][0] + l.m[1][0] * r.m[1][1] + l.m[2][0] * r.m[1][2] + l.m[3][0] * r.m[1][3],
    // 2,0
    l.m[0][0] * r.m[2][0] + l.m[1][0] * r.m[2][1] + l.m[2][0] * r.m[2][2] + l.m[3][0] * r.m[2][3],
    // 3,0
    l.m[0][0] * r.m[3][0] + l.m[1][0] * r.m[3][1] + l.m[2][0] * r.m[3][2] + l.m[3][0] * r.m[3][3],

    // 0,1
    l.m[0][1] * r.m[0][0] + l.m[1][1] * r.m[0][1] + l.m[2][1] * r.m[0][2] + l.m[3][1] * r.m[0][3],
    // 1,1
    l.m[0][1] * r.m[1][0] + l.m[1][1] * r.m[1][1] + l.m[2][1] * r.m[1][2] + l.m[3][1] * r.m[1][3],
    // 2,1
    l.m[0][1] * r.m[2][0] + l.m[1][1] * r.m[2][1] + l.m[2][1] * r.m[2][2] + l.m[3][1] * r.m[2][3],
    // 3,1
    l.m[0][1] * r.m[3][0] + l.m[1][1] * r.m[3][1] + l.m[2][1] * r.m[3][2] + l.m[3][1] * r.m[3][3],

    // 0,2
    l.m[0][2] * r.m[0][0] + l.m[1][2] * r.m[0][1] + l.m[2][2] * r.m[0][2] + l.m[3][2] * r.m[0][3],
    // 1,2
    l.m[0][2] * r.m[1][0] + l.m[1][2] * r.m[1][1] + l.m[2][2] * r.m[1][2] + l.m[3][2] * r.m[1][3],
    // 2,2
    l.m[0][2] * r.m[2][0] + l.m[1][2] * r.m[2][1] + l.m[2][2] * r.m[2][2] + l.m[3][2] * r.m[2][3],
    // 3,2
    l.m[0][2] * r.m[3][0] + l.m[1][2] * r.m[3][1] + l.m[2][2] * r.m[3][2] + l.m[3][2] * r.m[3][3],

    // 0,3
    l.m[0][3] * r.m[0][0] + l.m[1][3] * r.m[0][1] + l.m[2][3] * r.m[0][2] + l.m[3][3] * r.m[0][3],
    // 1,3
    l.m[0][3] * r.m[1][0] + l.m[1][3] * r.m[1][1] + l.m[2][3] * r.m[1][2] + l.m[3][3] * r.m[1][3],
    // 2,3
    l.m[0][3] * r.m[2][0] + l.m[1][3] * r.m[2][1] + l.m[2][3] * r.m[2][2] + l.m[3][3] * r.m[2][3],
    // 3,3
    l.m[0][3] * r.m[3][0] + l.m[1][3] * r.m[3][1] + l.m[2][3] * r.m[3][2] + l.m[3][3] * r.m[3][3],
  };
}
} // namespace Raytracer::Math
